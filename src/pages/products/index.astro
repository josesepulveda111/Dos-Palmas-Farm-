---
import ProductLayouts from "@/functional-components/product/ProductLayouts";
import ProductFilters from "@/functional-components/ProductFilters";
import ProductLayoutViews from "@/functional-components/ProductLayoutViews";
import Base from "@/layouts/Base.astro";
import { defaultSort, sorting } from "@/lib/constants";
// import { getCollectionProducts, getCollections, getHighestProductPrice, getProducts, getVendors } from "@/lib/shopify";
import { getLocalProducts, getLocalTags, getLocalVendors, getLocalHighestProductPrice } from "@/lib/local/products";
import { getLocalCollections } from "@/lib/local/collections";
import type { PageInfo, Product } from "@/lib/types";
import CallToAction from "@/partials/CallToAction.astro";

const searchParams = Astro.url.searchParams;
const sort = searchParams.get("sort") || "";
const searchValue = searchParams.get("q") || "";
const minPriceParam = searchParams.get("minPrice");
const maxPriceParam = searchParams.get("maxPrice");
const minPrice = minPriceParam ? Number(minPriceParam) : undefined;
const maxPrice = maxPriceParam ? Number(maxPriceParam) : undefined;
const brand = searchParams.get("b") || "";
const categoriesSelected = searchParams.getAll("c");
const tagsSelected = searchParams.getAll("t");
const cursor = searchParams.get("cursor") || null;

const { sortKey, reverse } =
  sorting.find((item) => item.slug === sort) || defaultSort;

let productsData: any;
let vendorsWithCounts: { vendor: string; productCount: number }[] = [];
let categoriesWithCounts: { category: string; productCount: number }[] = [];

if (searchValue || brand || typeof minPrice === 'number' || typeof maxPrice === 'number' || categoriesSelected.length > 0 || tagsSelected.length > 0) {
  try {
    productsData = await getLocalProducts({
      sortKey,
      reverse,
      cursor: cursor || undefined,
      categories: categoriesSelected,
      tags: tagsSelected,
      minPrice,
      maxPrice,
      search: searchValue,
    });
  } catch (error) {
    console.error("Error fetching products:", error);
    productsData = { products: [] };
  }

  const uniqueVendors: string[] = [
    ...new Set(
      ((productsData?.products as Product[]) || []).map((product: Product) =>
        String(product?.vendor || "")
      )
    ),
  ];

  const uniqueCategories: string[] = [
    ...new Set(
      ((productsData?.products as Product[]) || []).flatMap(
        (product: Product) =>
          product.collections.nodes.map(
            (collectionNode: any) => collectionNode.title || ""
          )
      )
    ),
  ];

  vendorsWithCounts = uniqueVendors.map((vendor: string) => {
    const productCount = (productsData?.products || []).filter(
      (product: Product) => product?.vendor === vendor
    ).length;
    return { vendor, productCount };
  });

  categoriesWithCounts = uniqueCategories.map((category: string) => {
    const productCount = ((productsData?.products as Product[]) || []).filter(
      (product: Product) =>
        product.collections.nodes.some(
          (collectionNode: any) => collectionNode.title === category
        )
    ).length;
    return { category, productCount };
  });
} else {
  // Fetch all products (local)
  try {
    productsData = await getLocalProducts({
      sortKey,
      reverse,
      cursor: cursor || undefined,
    });
  } catch (error) {
    console.error("Error fetching products:", error);
    productsData = { products: [] };
  }

  // Calculate category counts for all products when no filters are applied
  const uniqueCategories: string[] = [
    ...new Set(
      ((productsData?.products as Product[]) || []).flatMap(
        (product: Product) =>
          product.collections.nodes.map(
            (collectionNode: any) => collectionNode.title || ""
          )
      )
    ),
  ];

  categoriesWithCounts = uniqueCategories.map((category: string) => {
    const productCount = ((productsData?.products as Product[]) || []).filter(
      (product: Product) =>
        product.collections.nodes.some(
          (collectionNode: any) => collectionNode.title === category
        )
    ).length;
    return { category, productCount };
  });
}

const categories = await getLocalCollections();
const vendors = await getLocalVendors();

const tags = [
  ...new Set(
    (
      productsData as { pageInfo: PageInfo; products: Product[] }
    )?.products.flatMap((product: Product) => product.tags)
  ),
];

const maxPriceData = await getLocalHighestProductPrice();

const initialProducts = productsData.products;
const initialPageInfo = productsData.pageInfo;
---

<Base title="Products">
  <ProductLayouts
    categories={categories}
    tags={tags}
    maxPriceData={maxPriceData}
    categoriesWithCounts={categoriesWithCounts}
    client:only="react"
  />

  <div class="container">
    <div class="row">
      <div class="col-3 hidden lg:block -mt-14">
        <ProductFilters
          categories={categories}
          tags={tags}
          maxPriceData={maxPriceData}
          categoriesWithCounts={categoriesWithCounts}
          client:only="react"
        />
      </div>

      <ProductLayoutViews
        initialProducts={initialProducts}
        initialPageInfo={initialPageInfo}
        sortKey={sortKey}
        reverse={reverse}
        searchValue={searchValue}
        client:only="react"
      />
      <CallToAction />
    </div>
  </div>
</Base>
